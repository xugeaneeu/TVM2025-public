# Лабораторная работа 07: Алгебраическое упрощение

[RU|[EN](README.md)]

Цель этого упражнения - ознакомиться с принципами некоторых оптимизаций, применяемых в современных компиляторах. Конкретнее, мы займемся *алгебраическими* оптимизациями.

## Цель

В [предыдущей работе](../lab06/README.ru.md) есть подзадача по реализации ограниченного подмножества *оптимизаций выражений*. Так как мы точно знаем, что умножение `x` на `1` всегда возвращает `x`, а умножение на `0` возвращает `0`, в обоих случаях нам нет необходимости выполнять умножение *вне зависимости от фактического значения* `x`.

Интуитивно, мы ожидаем, что более "короткая" форма выражения будет более эффективной, так как ее вычисление требует выполнения меньшего количества операций. В более общем случае, однако, решение может быть не столь очевидным: при том же самом количестве операций они отличаться по эффективности. Некоторые промышленные компиляторы содержат довольно-таки сложные модели целевых процессоров для принятия обоснованных решений по вопросам оптимизации.

Мы формализуем это при помощи специальной функции `cost`, которая должна сопоставлять любому выражению неотрицательное целое значение; чем меньше это значение, тем "более оптимальным" является выражение.

Далее, мы расширим наивный подход из [предыдущей работы](../lab06/README.ru.md) на более широкий набор тождеств - к примеру, всякий раз, как мы встречаем выражение вида `x - x`, мы можем заменить его на `0`, и так далее. Однако, прямое кодирование каждого дополнения в этот список тождеств будет все сильнее усложнять наш упрощающий код. Как мы сможем быть (достаточно надежно) уверены в том, что все возможности по оптимизации исчерпаны?

Еще одной проблемой является применимость тождеств. Реальные программы не ограничиваются манипуляциями с целыми числами; возможны и другие типы данных, для которых списки тождеств могут отличаться. Разработка отдельных алгоритмов для оптимизаций, скажем, векторно-матричных операций, или арифметики чисел с плавающей запятой, кажется не слишком продуктивной.

Реализация общего алгоритма упрощения, который не опирается ни на какой конкретный список тождеств, преодолевает оба затруднения.

Именно этим мы и займемся в этой работе.

Функция упрощения будет принимать исходное выражение (`Expr`) и набор тождеств (массив кортежей `[Expr, Expr]`). Она должна возвращать *упрощенное* выражени, т.е. такую его форму, которая достигает минимального значения функции `cost`.

## Задачи

1. Реализуйте в файле [cost.ts](src/cost.ts) функцию `cost`, которая определяет стоимость вычисления выражения в соответствии со следующими правилами:
   - стоимость константного выражения равна нулю
   - стоимость обращения к переменной равна единице
   - стоимость унарного минуса равна 1 + стоимость его аргумента
   - стоимость бинарной операции равна 1 + сумма стоимостей обоих аргументов
2. Реализуйте в файле [simplify.ts](src/simplify.ts) функцию `simplify`, которая упрощает заданное выражение в соответствии с заданным набором тождеств

## Оценка

- C | 3 | Воу, воу, полегче:
  - Реализуйте упрощение, предполагая, что все тождества строго уменьшают стоимость выражения, и являются корректными
- B | 4 | Ломай меня полностью:
  - Реализуйте упрощение, предполагая, что все указанные тождества
    - являются корректными (наборы переменных на обеих сторонах тождества совпадают)
    - никогда не увеличивают стоимость выражений (и разверните те тождества, которые это нарушают)
- C | 5 | Мне все ультрафиолетово:
  - Реализуйте упрощение, разрешая временно увеличивать стоимость выражений
  - Используйте каждое тождество в обоих направлениях (напр. `a * (b+c) => a*b + a*c` также означает, что `a*b + a*c => a * (b+c)`)
  - Добавьте *свертку констант* для достижения дополнительной оптимизации (если все аргументы некоторого подвыражения являются константами, то все это подвыражение можно заменить на константу, рассчитанную в процессе оптимизации)

## Советы

1. Вне зависимости от выбранного алгоритма и подхода, ключевыми компонентами являются:
   - Проверка того, что некоторое тождество применимо к конкретному подвыражению
   - Трансформация подвыражения в соответствии с заданным тождеством

   При решении этих подзадач, помните следующее:
   - шаблон в левой части тождества, записанный как выражение (напр. `x + x`) соответствует выражению тогда и только тогда, когда совпадает выполняемая *операция*, и каждый из аргументов выражения соответствует аргументу шаблона.
   Ссылка на переменную соответствует *любому* выражению, если всем ссылкам на одну и ту же переменную сопоставлено одно и то же выражение. Так, `42+42` соответствует шаблону выше, а `42+1` - нет. И `(a*2) + (a*2)` и `y + y` соответствуют тому же шаблону, а `(2*a) + (a*2)` - не соответствует.
   - для того, чтобы выполнить трансформацию, нам нужно знать, какое подвыражение сопоставляется каждой из переменных, упомянутых в правиле. Имеет смысл совместить процесс проверки выражения на соответствие шаблону с процессом построения карты сопоставления переменных.
2. Помните, что однократное применение тождества не обязательно приводит к оптимальному решению. К полученному выражению могут применяться и другие трансформации из списка тождеств, и так далее.

3. При снятии ограничения "использовать только улучшающие трансформации", некоторые тождества могут многократно применяться к некоторому подвыражению, приводя к циклам. Простые циклы являются очевидными (`x + y => y + x => x + y`), другие могут быть более длинными и включать несколько различных тождеств (`a + (b + c) => b + (c + a) => c + (a + b) => a + (b + c)`). Корректное решение должно учитывать этот факт и предотвращать бесконечное зацикливание с перебором одних и тех же форм выражения.
