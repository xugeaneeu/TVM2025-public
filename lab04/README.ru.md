# Лабораторная работа 04: Разбор выражений и построение AST

[RU|[EN](README.md)]

Эта работа применяет грамматику из [предыдущей работы](../lab03/README.ru.md) для построения [*Абстрактного синтаксического дерева*][AST] (Abstract Syntax Tree) для использования в следующих работах.

## Цель

Заметьте, что способ реализации функций `calculate` в лабораторных работах с 01 по 03 называется *интерпретацией*: на "основном" языке программирования написан код, который во время выполнения обрабатывает дерево разбора выражения и применяет записанные в нем операции.

Многие современные языки программирования не следуют этому подходу. Вместо этого, применяется процесс *трансляции* - преобразования программы на некотором исходном языке в эквивалентную ей программу на другом языке.

Несмотря на то, что процесс трансляции *может* быть основан непосредственно на дереве разбора, порождаемой библиотекой Ohm, этот способ не является общепринятым.

Реальные компиляторы применяют довольно много трансформаций к синтаксическим деревьям, построенным по исходному коду, перед порождением выходной программы.

Построение Абстрактного Синтаксического Дерева из наших "собственных" узлов, а не из тех, что автоматически порождаются сторонней библиотекой, предоставляет нам необходимую для таких трансформаций гибкость.

Мы также будем экспортировать основные типы узлов нашего дерева для использования в следующих лабораторных работах.

## Задачи

1. Реализуйте AST арифетических выражений путем объявления типов данных для всех видов выражений в файле [ast.ts](src/ast.ts). Наиболее общий тип должен называться `Expr`, именование подтипов остается на усмотрение студента.
2. Реализуйте в файле [parser.ts](src/parser.ts) семантическую операцию `parse()`, которая конвертирует результат разбора выражения грамматикой Ohm в это AST.
3. Реализуйте в файле [parser.ts](src/parser.ts функцию `parseExpr(string)`, которая применяет к входной строке грамматику и строит AST при помощи семантического действия, описанного в предыдущем пункте.
4. Реализуйте в файле [printExpr.ts](src/printExpr.ts) "обратную" функцию с названием `printExpr`, которая преобразует AST обратно в текст выражения.

## Оценка

- C | 3 | Воу, воу, полегче:
  - Реализуйте поддержку всех операций в построении AST и обратной конверсии в текст
- B | 4 | Ломай меня полностью:
  - При порождении текста не используйте скобки сверх необходимых

## Советы

1. Есть несколько способов представлять AST в системе типов Typescript. См. более подробное обсуждение в [ast.ru.md](ast.ru.md).
2. Детектирование необходимости скобок может вызвать затруднения. Помните, что скобки используются для *изменения* порядка операций, определенного при помощи приоритета и/или ассоциативности. Так что для принятия решения об использовании скобок вокруг выражения нужно сравнивать *контекст*, в котором это выражение используется, с операцией, которую представляет выражение.
3. Передача информации о контексте в функцию печати может потребовать дополнительных параметров. Прямолинейный способ реализации этого требования - объявить дополнительную рекурсивную функцию с подходящей сигнатурой. Однако, TS/JS допускает некоторые вольности в определении функций: можно добавить дополительные параметры в сигнатуру основной функции `printExpr`, если эти параметры являются *необязательными*. Это позволяет обойтись одной функцией и для экспорта, и для рекурсивного обхода.

[AST]: https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE
